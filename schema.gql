type File {
	id: Int!
	backendName: String!
	key: String!
	pendingAutoMatch: Int!
	unavailableSince: Int
	editionName: String
	resolution: Int
	sizeBytes: Int
	scannedAt: Int!
}

type Invite {
	code: String!
	permissions: Int!
	createdBy: String!
	createdAt: Int!
	expiresAt: Int!
	usedAt: Int
	usedBy: String
}

type Media {
	id: Int!
	name: String!
	description: String
	posterUrl: String
	backgroundUrl: String
	thumbnailUrl: String
	parentId: Int
	mediaType: MediaType!
	imdbParentId: String
	imdbItemId: String
	tmdbParentId: Int!
	tmdbItemId: Int!
	rating: Float
	startDate: Int
	endDate: Int
	runtimeMinutes: Int
	seasonNumber: Int
	episodeNumber: Int
	"""
	the time a file was linked to the media item (aka, added_at)
	"""
	firstLinkedAt: Int
	createdAt: Int!
	updatedAt: Int
	"""
	Gets the default file connection for this media item, including child connections.
	(this is what should be played if the user hits "play" on this media item)
	"""
	defaultConnection: File
	seasons: [Int!]!
	parent: Media
	watchState: WatchState
}

type MediaConnection {
	"""
	Information to aid in pagination.
	"""
	pageInfo: PageInfo!
	"""
	A list of edges.
	"""
	edges: [MediaEdge!]!
	"""
	A list of nodes.
	"""
	nodes: [Media!]!
}

"""
An edge in a connection.
"""
type MediaEdge {
	"""
	The item at the end of the edge
	"""
	node: Media!
	"""
	A cursor for use in pagination
	"""
	cursor: String!
}

input MediaFilter {
	parentId: Int
	seasonNumbers: [Int!]
	mediaTypes: [MediaType!]
	search: String
	orderBy: MediaOrderBy
	orderDirection: OrderDirection
	watched: Boolean
}

enum MediaOrderBy {
	ADDED_AT
	RELEASED_AT
	ALPHABETICAL
	RATING
	SEASON_EPISODE
}

enum MediaType {
	MOVIE
	SHOW
	EPISODE
}

type Model {
	id: String!
	username: String!
	permissions: Int!
	defaultSubtitleBcp47: String
	defaultAudioBcp47: String
	subtitlesEnabled: Int!
	createdAt: Int!
	lastLoginAt: Int
}

type Mutation {
	signup(username: String!, password: String!, inviteCode: String): Model!
	createInvite(permissions: Int!): Invite!
	updateWatchState(mediaId: Int!, progressPercentage: Float!, userId: String): WatchState!
}

enum OrderDirection {
	ASC
	DESC
}

"""
Information about pagination in a connection
"""
type PageInfo {
	"""
	When paginating backwards, are there more items?
	"""
	hasPreviousPage: Boolean!
	"""
	When paginating forwards, are there more items?
	"""
	hasNextPage: Boolean!
	"""
	When paginating backwards, the cursor to continue.
	"""
	startCursor: String
	"""
	When paginating forwards, the cursor to continue.
	"""
	endCursor: String
}

type Query {
	mediaList(filter: MediaFilter!, after: String, first: Int): MediaConnection!
	media(mediaId: Int!): Media!
}

type WatchState {
	mediaId: Int!
	userId: String!
	progressPercentage: Float!
	createdAt: Int!
	updatedAt: Int!
}

"""
Directs the executor to include this field or fragment only when the `if` argument is true.
"""
directive @include(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT
"""
Directs the executor to skip this field or fragment when the `if` argument is true.
"""
directive @skip(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT
schema {
	query: Query
	mutation: Mutation
}
